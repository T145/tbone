package T145.tbone.core;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import T145.tbone.blocks.BlockModItem;
import net.minecraft.block.Block;
import net.minecraft.client.renderer.block.model.ModelResourceLocation;
import net.minecraft.client.renderer.tileentity.TileEntitySpecialRenderer;
import net.minecraft.item.Item;
import net.minecraft.util.IStringSerializable;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.StringUtils;
import net.minecraft.util.datafix.DataFixer;
import net.minecraft.util.datafix.FixTypes;
import net.minecraft.util.datafix.walkers.ItemStackDataLists;
import net.minecraftforge.client.model.ModelLoader;
import net.minecraftforge.fml.client.registry.ClientRegistry;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.fml.common.Mod.EventHandler;
import net.minecraftforge.fml.common.Mod.Instance;
import net.minecraftforge.fml.common.ModMetadata;
import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
import net.minecraftforge.fml.common.registry.GameRegistry;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import net.minecraftforge.registries.IForgeRegistry;

@Mod(modid = TBone.ID, name = TBone.NAME, version = TBone.VERSION, updateJSON = TBone.UPDATE_JSON)
public class TBone {

	/*
	 * These variables are localized here b/c this mod is a library,
	 * and essentially is an API. Therefore, it doesn't need an actual
	 * API package to interact w/ it (unless some part of it needs to
	 * be modified by a mod in the future).
	 * 
	 * - T145
	 */
	public static final String ID = "tbone";
	public static final String NAME = "TBone";
	public static final String VERSION = "@VERSION@";
	public static final String UPDATE_JSON = "https://raw.githubusercontent.com/T145/tbone/master/update.json";
	public static final Logger LOG = LogManager.getLogger(NAME);

	@Instance(ID)
	public static TBone instance;

	@EventHandler
	public void tbone$preInit(FMLPreInitializationEvent event) {
		ModMetadata meta = event.getModMetadata();
		meta.authorList.add("T145");
		meta.autogenerated = false;
		meta.credits = "The fans!";
		meta.description = "Shared code library for my Minecraft mods.";
		meta.logoFile = "logo.png";
		meta.modId = ID;
		meta.name = NAME;
		meta.url = "https://github.com/T145/tbone";
		meta.useDependencyInformation = false;
		meta.version = VERSION;
	}

	public static void registerInventoryFixes(DataFixer fixer, FixTypes type, Class clazz) {
		fixer.registerWalker(type, new ItemStackDataLists(clazz, new String[] { "Items" }));
	}

	public static void registerTileEntity(Class tileClass, String modId) {
		GameRegistry.registerTileEntity(tileClass, new ResourceLocation(modId, tileClass.getSimpleName()));
	}

	public static void registerItemBlock(IForgeRegistry<Item> registry, Block block) {
		registry.register(new BlockModItem(block));
	}

	public static void registerItemBlock(IForgeRegistry<Item> registry, Block block, IStringSerializable[] types) {
		registry.register(new BlockModItem(block, types));
	}

	@SideOnly(Side.CLIENT)
	public static ModelResourceLocation getCustomModel(String modId, Item item, String customDomain, StringBuilder variantPath) {
		if (StringUtils.isNullOrEmpty(customDomain)) {
			return new ModelResourceLocation(item.getRegistryName(), variantPath.toString());
		} else {
			return new ModelResourceLocation(String.format("%s:%s", modId, customDomain), variantPath.toString());
		}
	}

	@SideOnly(Side.CLIENT)
	public static void registerModel(String modId, Item item, String domain, int meta, String... variants) {
		StringBuilder path = new StringBuilder(variants[0]);

		for (short i = 1; i < variants.length; ++i) {
			path.append(',').append(variants[i]);
		}

		ModelLoader.setCustomModelResourceLocation(item, meta, getCustomModel(modId, item, domain, path));
	}

	@SideOnly(Side.CLIENT)
	public static void registerModel(String modId, Block block, String domain, int meta, String... variants) {
		registerModel(modId, Item.getItemFromBlock(block), domain, meta, variants);
	}

	@SideOnly(Side.CLIENT)
	public static void registerModel(String modId, Item item, int meta, String... variants) {
		registerModel(modId, item, null, meta, variants);
	}

	@SideOnly(Side.CLIENT)
	public static void registerModel(String modId, Block block, int meta, String... variants) {
		registerModel(modId, block, null, meta, variants);
	}

	@SideOnly(Side.CLIENT)
	public static void registerTileRenderer(Class tileClass, TileEntitySpecialRenderer tileRenderer) {
		ClientRegistry.bindTileEntitySpecialRenderer(tileClass, tileRenderer);
	}

	@SideOnly(Side.CLIENT)
	public static String getVariantName(IStringSerializable variant) {
		return String.format("variant=%s", variant.getName());
	}
}
